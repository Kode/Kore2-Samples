struct vertex_in {
	pos: float3;
}

struct vertex_out {
	pos: float4;
}

fun pos(input: vertex_in): vertex_out {
	var output: vertex_out;
	output.pos = float4(input.pos.x, input.pos.y, 0.5, 1.0);
	return output;
}

fun pixel(input: vertex_out): float4 {
	var color: float4 = float4(1.0, 0.0, 0.0, 1.0);
	return color;
}

#[pipe]
struct pipeline {
	vertex = pos;
	fragment = pixel;
}

struct fs_vertex_in {
	pos: float2;
}

struct fs_vertex_out {
	pos: float4;
	tex_coord: float2;
}

#[set(fs)]
const fs_texture: tex2d;

#[set(fs)]
const fs_sampler: sampler;

fun fs_pos(input: fs_vertex_in): fs_vertex_out {
	var output: fs_vertex_out;

	var madd: float2 = float2(0.5, 0.5);
	output.tex_coord = input.pos.xy * madd + madd;

	output.pos = float4(input.pos.x, input.pos.y, 0.0, 1.0);

	return output;
}

fun fs_pixel(input: fs_vertex_out): float4 {
	return sample_lod(fs_texture, fs_sampler, input.tex_coord, 4.0);
}

#[pipe]
struct fs_pipeline {
	vertex = fs_pos;
	fragment = fs_pixel;
}

#[root_constants]
const mip_constants: {
	size: uint2;
};

#[set(mip)]
const mip_source_texture: tex2d;

#[set(mip), write]
const mip_destination_texture: tex2d;

#[compute, threads(8, 8, 1)]
fun comp(): void {
	var index: uint2 = dispatch_thread_id().xy;
	if (index.x < mip_constants.size.x && index.y < mip_constants.size.y) {
		var source_index0: uint2 = index * 2;
		var source_index1: uint2 = uint2(source_index0.x + 1, source_index0.y);
		var source_index2: uint2 = uint2(source_index0.x, source_index0.y + 1);
		var source_index3: uint2 = uint2(source_index0.x + 1, source_index0.y + 1);

		mip_destination_texture[index] =
			(mip_source_texture[source_index0]
			+ mip_source_texture[source_index1]
			+ mip_source_texture[source_index2]
			+ mip_source_texture[source_index0]) / 4.0;
	}
}
